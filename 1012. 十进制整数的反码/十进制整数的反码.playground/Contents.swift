import UIKit


/*
 每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。
 
 二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。
 
 给定十进制数 N，返回其二进制表示的反码所对应的十进制整数。

 示例 1：
 
 输入：5
 输出：2
 解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。
 
 示例 2：
 
 输入：7
 输出：0
 解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。
 
 示例 3：
 
 输入：10
 输出：5
 解释：10 的二进制表示为 "1010"，其二进制反码为 "0101"，也就是十进制中的 5 。
 */


//位运算

/*
 先说一下布尔值的与、或、异或、反运算：
 与运算，两者都为真计算结果为真，反之为假：
 1 & 1 = 1，1 & 0 = 0，0 & 1 = 0，0 & 0 = 0；
 或运算，至少其一都为真计算结果为真，反之为假：
 1 | 1 = 1，1 | 0 = 1，0 | 1 = 1，0 | 0 = 0；
 异或运算，两者不同为真，反之为假：
 1 ^ 1 = 0，1 ^ 0 = 1，0 ^ 1 = 1，0 ^ 0 = 0；
 取反运算，单目运算符：
 ~1 = 0，~0 = 1；
 
double exp (double);求取自然数e的幂
double sqrt (double);开平方
double log (double); 以e为底的对数
double log10 (double);以10为底的对数
double pow(double x, double y）;计算以x为底数的y次幂
float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数
 
 */



func bitwiseComplement(_ N: Int) -> Int {
    
    if (N == 0 ){
        return 1
    }else{
        let bit = Int(log2(Double(N))) + 1
        return N ^ (Int(pow(2, Double(bit)))-1)
    }
}


bitwiseComplement(0)
